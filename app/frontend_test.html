<!DOCTYPE html>
<html>

<head>
    <title>WebRTC Test</title>
</head>

<body>
    <div style="font-family: sans-serif; max-width: 800px; margin: 0 auto; padding: 20px;">
        <h2>AI Proctoring Test Handler</h2>

        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
            <h3>1. Configuration</h3>
            <label>Candidate ID: <input type="text" id="candidateId" value="test-candidate-1"></label>
            <label>Session ID: <input type="text" id="sessionId" value="test-session-1"></label>
        </div>

        <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
            <h3>2. Enrollment</h3>
            <p>Capture 3 images to enroll your face.</p>
            <button onclick="startCamera()" id="btnStartCamera">Start Camera</button>
            <button onclick="stopCamera()" id="btnStopCamera" disabled>Stop Camera</button>
            <button onclick="captureEnrollmentImages()" id="btnCapture" disabled>Capture & Enroll</button>
            <div id="enrollmentStatus" style="margin-top: 5px;"></div>
            <div id="enrollmentDetails"
                style="margin-top: 5px; font-size: 0.9em; box-shadow: 0 0 5px #ccc; padding: 10px; display: none;">
            </div>
            <button onclick="fetchEnrollmentDetails()" style="margin-top: 10px;">Fetch Details</button>
        </div>

        <div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
            <h3>3. Exam Session</h3>
            <button onclick="startSession()">Start Session</button>
            <button onclick="connectWebRTC()" id="btnConnect" disabled>Connect WebRTC</button>
            <button onclick="disconnectWebRTC()" id="btnDisconnect" disabled>Disconnect</button>
            <div id="sessionStatus" style="margin-top: 5px;"></div>
        </div>

        <h3>Live Monitor</h3>
        <div style="display: flex; gap: 20px;">
            <div>
                <h4>Local Stream</h4>
                <video id="video" autoplay playsinline muted width="320" height="240"
                    style="background: black;"></video>
                <div id="cameraStatus" style="margin-top: 5px; font-size: 0.9em; color: #666;"></div>
                <div id="frameStats" style="margin-top: 5px; font-size: 0.9em; color: #007bff; font-weight: bold;">
                    Frames Sent: 0</div>
            </div>
            <div style="flex-grow: 1;">
                <h4>Real-time Alerts (DataChannel)</h4>
                <div id="alerts"
                    style="border:1px solid #ccc; height: 240px; overflow-y: auto; padding: 10px; background: #fff;">
                    <i>Waiting for connection...</i>
                </div>
            </div>
        </div>
    </div>

    <script>
        const APP_URL = "{{APP_URL}}"; // Will be replaced by backend
        let pc;
        let dc;
        let stream;

        async function startCamera() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                document.getElementById("video").srcObject = stream;

                // Update UI
                document.getElementById("btnStartCamera").disabled = true;
                document.getElementById("btnStopCamera").disabled = false;
                document.getElementById("btnCapture").disabled = false;
                document.getElementById("cameraStatus").innerHTML = '<span style="color: green;">● Camera Active</span>';
            } catch (e) {
                alert("Camera error: " + e.message);
                document.getElementById("cameraStatus").innerHTML = '<span style="color: red;">Camera Error</span>';
            }
        }

        function stopCamera() {
            if (stream) {
                // Stop all tracks
                stream.getTracks().forEach(track => track.stop());

                // Clear video element
                const video = document.getElementById("video");
                video.srcObject = null;

                // Reset stream variable
                stream = null;

                // Update UI
                document.getElementById("btnStartCamera").disabled = false;
                document.getElementById("btnStopCamera").disabled = true;
                document.getElementById("btnCapture").disabled = true;
                document.getElementById("cameraStatus").innerHTML = '<span style="color: gray;">● Camera Stopped</span>';

                // If WebRTC is connected, warn user
                if (pc && pc.connectionState === 'connected') {
                    alert("Warning: Camera stopped but WebRTC connection is still active. Video stream to server has ended.");
                }
            }
        }

        function getFrameBase64() {
            const video = document.getElementById("video");
            if (!stream || !video.srcObject) {
                alert("Camera is not active. Please start the camera first.");
                return null;
            }
            const canvas = document.createElement("canvas");
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext("2d").drawImage(video, 0, 0);
            return canvas.toDataURL("image/jpeg").split(",")[1];
        }

        async function captureEnrollmentImages() {
            const candidateId = document.getElementById("candidateId").value;
            const statusDiv = document.getElementById("enrollmentStatus");

            if (!stream) {
                statusDiv.innerHTML = "<span style='color:red'>Please start the camera first!</span>";
                return;
            }

            statusDiv.innerText = "Capturing 3 images...";

            const images = [];
            for (let i = 0; i < 3; i++) {
                const frameData = getFrameBase64();
                if (!frameData) {
                    statusDiv.innerHTML = "<span style='color:red'>Failed to capture image!</span>";
                    return;
                }
                images.push({ image_base64: frameData });
                statusDiv.innerText = `Capturing image ${i + 1}/3...`;
                await new Promise(r => setTimeout(r, 500)); // Delay between captures
            }

            statusDiv.innerText = "Sending enrollment request...";

            try {
                const res = await fetch(`${APP_URL}/api/v1/enroll`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        candidate_id: candidateId,
                        images: images
                    })
                });

                if (res.ok) {
                    const data = await res.json();
                    statusDiv.innerHTML = `<span style='color:green'>Enrollment Successful! ID: ${data.enrollment_id}</span>`;
                } else {
                    const err = await res.text();
                    statusDiv.innerHTML = `<span style='color:red'>Error: ${err}</span>`;
                }
            } catch (e) {
                statusDiv.innerHTML = `<span style='color:red'>Network Error: ${e.message}</span>`;
            }
        }

        async function fetchEnrollmentDetails() {
            const candidateId = document.getElementById("candidateId").value;
            const detailsDiv = document.getElementById("enrollmentDetails");

            try {
                const res = await fetch(`${APP_URL}/api/v1/enroll/${candidateId}`);
                if (res.ok) {
                    const data = await res.json();
                    detailsDiv.style.display = 'block';

                    let html = `
                        <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                            <div style="flex: 1;">
                                <h4>Enrollment Summary</h4>
                                <ul style="list-style: none; padding: 0;">
                                    <li><b>Candidate ID:</b> ${data.candidate_id}</li>
                                    <li><b>Enrollment ID:</b> ${data.enrollment_id}</li>
                                    <li><b>Timestamp:</b> ${new Date(data.enrollment_timestamp).toLocaleString()}</li>
                                    <li><b>Avg Embedding Stored:</b> ${data.average_embedding_stored ? 'Yes' : 'No'}</li>
                                </ul>
                            </div>
                    `;

                    if (data.embeddings && data.embeddings.length > 0) {
                        const emb = data.embeddings[0]; // Usually returns 1 best
                        html += `
                            <div style="flex: 1; text-align: center;">
                                <h4>Reference Face</h4>
                                <img src="${emb.face_image}"
                                     style="max-width: 150px; border: 2px solid #4caf50; border-radius: 8px;">
                                <div style="margin-top: 5px; font-size: 0.85em;">
                                    <div>Quality Score: <b>${emb.quality_score.toFixed(2)}</b></div>
                                    <div>Sharpness: <b>${emb.sharpness_score.toFixed(2)}</b></div>
                                </div>
                            </div>
                        `;
                    }
                    html += `</div>`;

                    detailsDiv.innerHTML = html;
                } else {
                    alert("Failed to fetch details: " + await res.text());
                }
            } catch (e) {
                alert("Error: " + e.message);
            }
        }

        async function startSession() {
            const sessionId = document.getElementById("sessionId").value;
            const candidateId = document.getElementById("candidateId").value;
            const statusDiv = document.getElementById("sessionStatus");

            statusDiv.innerText = "Starting session...";

            try {
                const res = await fetch(`${APP_URL}/api/v1/session/start`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        exam_session_id: sessionId,
                        candidate_id: candidateId,
                        verification_policy: {
                            face_match_threshold: 0.75,
                            alert_sensitivity: "medium"
                        }
                    })
                });

                if (res.ok) {
                    statusDiv.innerHTML = '<span style="color: green;">Session Active. Ready to connect WebRTC.</span>';
                    document.getElementById("btnConnect").disabled = false;
                } else {
                    statusDiv.innerHTML = '<span style="color: red;">Error starting session: ' + await res.text() + '</span>';
                }
            } catch (e) {
                statusDiv.innerHTML = '<span style="color: red;">Network Error: ' + e.message + '</span>';
            }
        }

        async function connectWebRTC() {
            const sessionId = document.getElementById("sessionId").value;
            const candidateId = document.getElementById("candidateId").value;

            if (!stream) {
                alert("Please start the camera before connecting WebRTC!");
                return;
            }

            // Create PC
            const config = {
                iceServers: [
                    { urls: "stun:stun.l.google.com:19302" },
                    {
                        urls: "turn:10.24.17.104:3478",
                        username: "user",
                        credential: "password"
                    }
                ]
            };
            pc = new RTCPeerConnection(config);

            // Connection State Logging
            pc.onconnectionstatechange = () => {
                console.log("Connection State:", pc.connectionState);
                document.getElementById('sessionStatus').innerText = `State: ${pc.connectionState}`;
            };
            pc.oniceconnectionstatechange = () => console.log("ICE State:", pc.iceConnectionState);

            // Debug Stats
            setInterval(async () => {
                if (pc && pc.connectionState === 'connected') {
                    const stats = await pc.getStats();
                    stats.forEach(report => {
                        if (report.type === 'outbound-rtp' && report.kind === 'video') {
                            const framesSent = report.framesSent || 0;
                            document.getElementById("frameStats").innerText = `Frames Sent: ${framesSent}`;
                            console.log(`Video Stats: BytesSent: ${report.bytesSent}, PacketsSent: ${report.packetsSent}, FramesSent: ${framesSent}`);
                        }
                    });
                }
            }, 1000);

            // Add Transceiver (Send only)
            stream.getTracks().forEach(track => pc.addTransceiver(track, { direction: 'sendonly' }));

            // Create DataChannel (Client initiates)
            dc = pc.createDataChannel("alerts");
            setupDataChannel(dc);

            // Create Offer
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            // Send to Backend
            try {
                const response = await fetch(`${APP_URL}/api/v1/signaling/offer`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        sdp: pc.localDescription.sdp,
                        type: pc.localDescription.type,
                        exam_session_id: sessionId,
                        candidate_id: candidateId
                    })
                });

                if (!response.ok) {
                    alert("Signaling failed: " + await response.text());
                    return;
                }

                const answer = await response.json();
                await pc.setRemoteDescription(answer);

                document.getElementById("btnConnect").disabled = true;
                document.getElementById("btnConnect").innerText = "Connected";
                document.getElementById("btnConnect").style.background = "#4caf50";
                document.getElementById("btnConnect").style.color = "white";
                document.getElementById("btnDisconnect").disabled = false;
            } catch (e) {
                alert("WebRTC connection failed: " + e.message);
            }
        }

        function disconnectWebRTC() {
            // Close data channel
            if (dc) {
                dc.close();
                dc = null;
            }

            // Close peer connection
            if (pc) {
                pc.close();
                pc = null;
            }

            // Update UI
            document.getElementById("btnConnect").disabled = false;
            document.getElementById("btnConnect").innerText = "Connect WebRTC";
            document.getElementById("btnConnect").style.background = "";
            document.getElementById("btnConnect").style.color = "";
            document.getElementById("btnDisconnect").disabled = true;

            // Clear alerts
            document.getElementById("alerts").innerHTML = "<i>Connection closed. Waiting for new connection...</i>";

            document.getElementById("sessionStatus").innerHTML += '<br><span style="color: orange;">WebRTC Disconnected</span>';
        }

        function setupDataChannel(channel) {
            channel.onmessage = (event) => {
                const data = JSON.parse(event.data);
                const el = document.getElementById("alerts");
                const div = document.createElement("div");
                div.style.borderBottom = "1px solid #eee";
                div.style.padding = "5px";
                div.innerText = `${new Date().toLocaleTimeString()} - ${data.message} (Score: ${data.severity_score}) (sim: ${data?.evidence?.similarity_score})`;
                if (data.severity_score > 0.8) div.style.color = "red";
                else if (data.severity_score > 0.5) div.style.color = "orange";
                el.prepend(div);
            };
            channel.onopen = () => {
                console.log("DataChannel Open");
                const el = document.getElementById("alerts");
                el.innerHTML = "<i style='color: green;'>DataChannel connected - Listening for alerts...</i>";
            };
            channel.onclose = () => {
                console.log("DataChannel Closed");
            };
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            stopCamera();
            disconnectWebRTC();
        });
    </script>
</body>

</html>